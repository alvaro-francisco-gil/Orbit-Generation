# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_visualization.ipynb.

# %% auto 0
__all__ = ['visualize_static_orbits', 'export_dynamic_orbits_html', 'plot_grouped_features', 'plot_value_proportions',
           'plot_latent_space_2d']

# %% ../nbs/03_visualization.ipynb 2
import numpy as np
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from typing import Optional, List, Dict, Any

# %% ../nbs/03_visualization.ipynb 6
def visualize_static_orbits(data: np.ndarray,  # The orbit data with shape (num_orbits, 6, num_time_points).
                            time_instants: Optional[List[int]] = None,  # Time points to highlight; defaults to None.
                            orbit_indices: Optional[List[int]] = None,  # Indices of orbits to visualize; defaults to all.
                            point_dict: Optional[Dict[str, tuple]] = None,  # Dictionary of extra points to plot.
                            show_legend: bool = True,  # Flag to indicate whether to show a legend.
                            save_path: Optional[str] = None,  # Path to save the figure; defaults to None.
                            plot_reference_box: bool = True  # Flag to indicate whether to plot the reference box.
                           ) -> None:
    """
    Visualizes orbits in 3D space and highlights specified time instants for each selected orbit.
    """
    
    # Use Matplotlib's Computer Modern font
    plt.rcParams.update({
        'font.family': 'serif',
        'font.serif': ['DejaVu Serif'],
        'font.size': 10,
        'text.usetex': False
    })

    if time_instants is None:
        time_instants = []  # Initialize to empty list if None.

    # Validate time instants are within the range of available time points.
    max_time_instants = data.shape[2]
    for time_instant in time_instants:
        if time_instant < 0 or time_instant >= max_time_instants:
            raise ValueError(f"Time instant {time_instant} is out of range.")

    # Validate orbit indices are within the range of available orbits.
    num_orbits = data.shape[0]
    if orbit_indices is None:
        orbit_indices = range(num_orbits)  # Use all orbits by default.
    else:
        for index in orbit_indices:
            if index < 0 or index >= num_orbits:
                raise ValueError(f"Orbit index {index} is out of range.")

    # Setup a 3D plot.
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Plot each selected orbit.
    for index in orbit_indices:
        X = data[index, 0, :]  # X coordinates
        Y = data[index, 1, :]  # Y coordinates
        Z = data[index, 2, :]  # Z coordinates
        ax.plot(X, Y, Z, label=f'Orbit {index}', alpha=0.5)  # Plot each orbit with a label.

    # Generate a color map for time instants if they exist.
    colors = plt.cm.jet(np.linspace(0, 1, len(time_instants)))

    # Highlight specified time instants and add to the legend.
    legend_added = set()  # Track which labels have been added to the legend
    if time_instants:
        for time_instant, color in zip(time_instants, colors):
            for index in orbit_indices:
                posx, posy, posz = data[index, 0:3, time_instant]
                label = f'Time {time_instant}'
                if label not in legend_added:
                    ax.scatter(posx, posy, posz, color=color, s=100, zorder=5, label=label)
                    legend_added.add(label)
                else:
                    ax.scatter(posx, posy, posz, color=color, s=100, zorder=5)

    # Plot additional points if provided.
    if point_dict:
        for point_name, coords in point_dict.items():
            ax.scatter(*coords, label=point_name, s=100, depthshade=True)  # Always add label for point_dict entries.

    # Set labels and title.
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    plt.title('3D Orbits Static Visualization')

    # Display the legend if requested.
    if show_legend:
        ax.legend()

    # Set the background color and plot reference box if requested.
    if plot_reference_box:
        ax.set_facecolor('white')  # White background
        ax.grid(True)  # Show grid
        # Set limits for the reference box
        ax.set_xlim([data[:, 0, :].min(), data[:, 0, :].max()])
        ax.set_ylim([data[:, 1, :].min(), data[:, 1, :].max()])
        ax.set_zlim([data[:, 2, :].min(), data[:, 2, :].max()])
    else:
        ax.set_facecolor('white')
        ax.grid(False)
        ax.set_xticks([])
        ax.set_yticks([])
        ax.set_zticks([])

    # Save the figure if a save path is provided.
    if save_path:
        plt.savefig(save_path)

    # Show the plot.
    plt.show()

# %% ../nbs/03_visualization.ipynb 13
def export_dynamic_orbits_html(data: np.ndarray,  # Orbit data as a 3D numpy array (num_orbits, 6, num_time_points).
                               time_instants: Optional[List[int]] = None,  # Time instants to highlight.
                               orbit_indices: Optional[List[int]] = None,  # Indices of orbits to visualize.
                               point_dict: Optional[Dict[str, tuple]] = None,  # Named points as a dict with 3D coordinates.
                               filename: str = 'orbits.html'  # Path and name of the file to save the HTML plot.
                               ) -> None:
    """
    Generates an interactive 3D visualization of orbits and saves it as an HTML file, including the ability to
    highlight specific time instants and show named points.
    """
    if time_instants is None:
        time_instants = []  # Ensure time_instants is initialized if None.

    num_orbits = data.shape[0]  # Total number of orbits in the dataset.
    if orbit_indices is None:
        orbit_indices = list(range(num_orbits))  # Default to visualizing all orbits if none specified.

    fig = go.Figure()  # Initialize the plotly figure.

    # Validate and plot each orbit.
    for index in orbit_indices:
        if index < 0 or index >= num_orbits:
            raise ValueError(f"Orbit index {index} is out of range.")
        
        # Extract coordinates for the plot.
        X = data[index, 0, :]  # X coordinates.
        Y = data[index, 1, :]  # Y coordinates.
        Z = data[index, 2, :]  # Z coordinates.
        fig.add_trace(go.Scatter3d(x=X, y=Y, z=Z, mode='lines',
                                   name=f'Orbit {index}',
                                   legendgroup=f'orbit{index}',
                                   showlegend=True))

        # Highlight specific time instants.
        if time_instants:
            for timestamp in time_instants:
                if timestamp < 0 or timestamp >= data.shape[2]:
                    raise ValueError(f"The provided timestamp {timestamp} is out of range.")
                highlight_x = [data[index, 0, timestamp]]
                highlight_y = [data[index, 1, timestamp]]
                highlight_z = [data[index, 2, timestamp]]
                fig.add_trace(go.Scatter3d(x=highlight_x, y=highlight_y, z=highlight_z, mode='markers',
                                           marker=dict(size=5, color='red'),
                                           name=f'Highlight {index} @ {timestamp}',
                                           legendgroup=f'orbit{index}',
                                           showlegend=False))

    # Add additional points from point_dict to the plot.
    if point_dict:
        for point_name, coords in point_dict.items():
            fig.add_trace(go.Scatter3d(x=[coords[0]], y=[coords[1]], z=[coords[2]], mode='markers',
                                       marker=dict(size=5),
                                       name=point_name))

    # Configure the layout of the plot.
    fig.update_layout(title='3D Orbits Visualization',
                      scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'),
                      width=800, height=600,
                      legend_title="Orbits Legend",
                      clickmode='event+select')

    # Write the plot to an HTML file.
    fig.write_html(filename)
    print(f"Visualization saved to {filename}")

# %% ../nbs/03_visualization.ipynb 18
def plot_grouped_features(df: pd.DataFrame,               # DataFrame containing the data.
                          columns: List[str],             # List of column names to plot.
                          group_col: str,                 # Column name to group by.
                          plot_type: str                  # Type of plot: 'violin', 'box', 'facetgrid', or 'histogram'
                         ) -> None:
    """
    Group the DataFrame by a specified column and plot the specified type of plot for each column for each group.
    """
    if plot_type not in ['violin', 'box', 'facetgrid', 'histogram']:
        raise ValueError("plot_type must be one of 'violin', 'box', 'facetgrid', or 'histogram'")
    
    if plot_type in ['violin', 'box']:
        # Set up the matplotlib figure
        fig, axs = plt.subplots(1, len(columns), figsize=(5 * len(columns), 5))
        
        # If only one column, axs is not an array, so make it an array
        if len(columns) == 1:
            axs = [axs]
        
        # Plot each specified column
        for i, column in enumerate(columns):
            if plot_type == 'violin':
                sns.violinplot(x=group_col, y=column, data=df, ax=axs[i])
                axs[i].set_title(f'Violin plot of {column.capitalize()} by {group_col.capitalize()}')
            elif plot_type == 'box':
                sns.boxplot(x=group_col, y=column, data=df, ax=axs[i])
                axs[i].set_title(f'Box plot of {column.capitalize()} by {group_col.capitalize()}')
            axs[i].set_xlabel(group_col.capitalize())
            axs[i].set_ylabel(column.capitalize())
        
        # Adjust layout and show the plot
        plt.tight_layout()
        plt.show()

    elif plot_type == 'facetgrid':
        for column in columns:
            g = sns.FacetGrid(df, col=group_col, col_wrap=4, height=4, sharex=False, sharey=False)
            g.map(plt.hist, column, bins=20, edgecolor='black')
            g.set_axis_labels(column.capitalize(), 'Frequency')
            g.set_titles(col_template=f"{column.capitalize()} | {{col_name}} {group_col}")
            plt.show()

    elif plot_type == 'histogram':
        # Group by the specified column
        grouped = df.groupby(group_col)

        # Plot histograms for each group
        for group_name, group in grouped:
            num_columns = len(columns)
            fig, axs = plt.subplots(1, num_columns, figsize=(5 * num_columns, 5))
            
            # If only one column, axs is not an array, so make it an array
            if num_columns == 1:
                axs = [axs]
            
            # Plot each specified column
            for i, column in enumerate(columns):
                axs[i].hist(group[column], bins=20, edgecolor='black')
                axs[i].set_title(f'{column.capitalize()} for {group_col.capitalize()}: {group_name}')
                axs[i].set_xlabel(column.capitalize())
                axs[i].set_ylabel('Frequency')
                axs[i].grid(True)
            
            # Adjust layout and show the plot
            plt.tight_layout()
            plt.show()

# %% ../nbs/03_visualization.ipynb 19
def plot_value_proportions(df: pd.DataFrame,             # DataFrame containing the data.
                           values_list: List[int],       # List of ID values to filter the DataFrame.
                           id_col: str                   # Column name to be used as ID.
                          ) -> None:
    """
    Filter the DataFrame based on values_list and plot pie charts for each column except the ID column.
    The total number of unique values in each column is displayed in the middle of each pie chart.
    """
    # Filter the DataFrame to include only the rows with IDs in values_list
    filtered_df = df[df[id_col].isin(values_list)]
    
    # Number of columns to plot
    num_cols = len(df.columns) - 1  # Excluding the ID column
    
    # Create a figure with subplots arranged horizontally
    fig, axes = plt.subplots(1, num_cols, figsize=(num_cols * 6, 6))
    
    # Plot pie charts for each column except the ID column
    for i, column in enumerate(df.columns):
        if column == id_col:
            continue
        values = filtered_df[column].value_counts()
        axes[i-1].pie(values, labels=values.index, autopct='%1.1f%%', startangle=140)
        axes[i-1].set_title(f'Proportion of values in {column}')
        axes[i-1].axis('equal')  # Equal aspect ratio ensures the pie is drawn as a circle.
        
        # Calculate and print the total number of classes in the middle
        total_classes = len(values)
        axes[i-1].text(0, 0, str(total_classes), ha='center', va='center', fontsize=12, weight='bold')
    
    plt.tight_layout()
    plt.show()

# %% ../nbs/03_visualization.ipynb 21
def plot_latent_space_2d(latent_representations: np.ndarray,  # Precomputed latent representations (numpy array).
                         labels: np.ndarray,                  # Labels for the data points, used for coloring in the plot.
                         figsize: tuple = (12, 9),            # Size of the figure for the plot.
                         save_path: Optional[str] = None,     # Optional path to save the plot image.
                         many_classes: bool = False,          # Flag to use enhanced plotting for many classes.
                         **kwargs: Any                        # Additional keyword arguments for the plotting.
                        ) -> None:
    """
    Plots and optionally saves the latent space representations assuming they are already in 2D.
    """
    # Encode string labels to integers
    label_encoder = LabelEncoder()
    encoded_labels = label_encoder.fit_transform(labels)
    class_names = label_encoder.classes_

    markers = ['o', 's', '^', 'v', 'D', '<', '>', 'p', '*', 'h', 'H', '8']  # Marker styles

    fig, ax = plt.subplots(figsize=figsize)

    if many_classes:
        for class_idx, class_name in enumerate(class_names):
            class_mask = (encoded_labels == class_idx)
            marker = markers[class_idx % len(markers)]
            ax.scatter(latent_representations[class_mask, 0], latent_representations[class_mask, 1],
                       label=class_name, marker=marker, s=30, **kwargs)
        ax.legend(title="Classes")
    else:
        unique_labels = np.unique(encoded_labels)
        for class_idx, class_name in zip(unique_labels, class_names):
            class_mask = (encoded_labels == class_idx)
            ax.scatter(latent_representations[class_mask, 0], latent_representations[class_mask, 1],
                       label=class_name, s=30, **kwargs)
        ax.legend(title="Classes")

    ax.set_title('2D Latent Space Visualization')
    ax.set_xlabel('Dimension 1')
    ax.set_ylabel('Dimension 2')

    plt.tight_layout()
    if save_path:
        plt.savefig(save_path, bbox_inches='tight')
        print(f"Saved plot to {save_path}")
    plt.show()

