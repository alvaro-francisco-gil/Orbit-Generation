# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_processing.ipynb.

# %% auto 0
__all__ = ['resample_3d_array', 'average_downsample_3d_array']

# %% ../nbs/02_processing.ipynb 2
from scipy.interpolate import interp1d
import numpy as np
import time

# %% ../nbs/02_processing.ipynb 5
def resample_3d_array(data, axis, target_size):
    """
    Resample a 3D numpy array along a specified axis using linear interpolation, with correct dimension handling.

    Parameters:
        data (numpy.ndarray): The original 3D array.
        axis (int): The axis along which to perform the interpolation (0, 1, or 2).
        target_size (int): The desired size of the specified axis after interpolation.
    
    Returns:
        numpy.ndarray: A new array with the specified axis resized to `target_size`.
    """
    # Validate the axis
    if axis not in [0, 1, 2]:
        raise ValueError("Invalid axis. Axis must be 0, 1, or 2.")

    # Prepare indices for interpolation
    old_indices = np.linspace(0, 1, num=data.shape[axis])
    new_indices = np.linspace(0, 1, num=target_size)

    # Initialize the output array
    new_shape = list(data.shape)
    new_shape[axis] = target_size
    new_data = np.empty(new_shape, dtype=data.dtype)
    
    # Perform interpolation along the specified axis
    if axis == 0:
        for i in range(data.shape[1]):
            for j in range(data.shape[2]):
                interpolator = interp1d(old_indices, data[:, i, j], kind='linear')
                new_data[:, i, j] = interpolator(new_indices)
    elif axis == 1:
        for i in range(data.shape[0]):
            for j in range(data.shape[2]):
                interpolator = interp1d(old_indices, data[i, :, j], kind='linear')
                new_data[i, :, j] = interpolator(new_indices)
    else:
        for i in range(data.shape[0]):
            for j in range(data.shape[1]):
                interpolator = interp1d(old_indices, data[i, j, :], kind='linear')
                new_data[i, j, :] = interpolator(new_indices)

    return new_data

# %% ../nbs/02_processing.ipynb 6
def average_downsample_3d_array(data, axis, target_size):
    """
    Downsample a 3D numpy array along a specified axis using averaging.

    Parameters:
        data (numpy.ndarray): The original 3D array.
        axis (int): The axis along which to perform the downsampling (0, 1, or 2).
        target_size (int): The desired size of the specified axis after downsampling.
    
    Returns:
        numpy.ndarray: A new array with the specified axis resized to `target_size`.
    """
    # Validate the axis
    if axis not in [0, 1, 2]:
        raise ValueError("Invalid axis. Axis must be 0, 1, or 2.")

    # Determine the number of elements in each block to be averaged
    original_size = data.shape[axis]
    block_size = original_size / target_size

    # Initialize the output array
    new_shape = list(data.shape)
    new_shape[axis] = target_size
    new_data = np.empty(new_shape, dtype=data.dtype)

    # Perform averaging along the specified axis
    if axis == 0:
        for i in range(target_size):
            start_idx = int(i * block_size)
            end_idx = int((i + 1) * block_size)
            new_data[i, :, :] = np.mean(data[start_idx:end_idx, :, :], axis=0)
    elif axis == 1:
        for i in range(target_size):
            start_idx = int(i * block_size)
            end_idx = int((i + 1) * block_size)
            new_data[:, i, :] = np.mean(data[:, start_idx:end_idx, :], axis=1)
    else:  # axis == 2
        for i in range(target_size):
            start_idx = int(i * block_size)
            end_idx = int((i + 1) * block_size)
            new_data[:, :, i] = np.mean(data[:, :, start_idx:end_idx], axis=2)

    return new_data
